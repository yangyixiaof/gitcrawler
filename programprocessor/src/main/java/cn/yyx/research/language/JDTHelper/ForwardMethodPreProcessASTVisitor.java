package cn.yyx.research.language.JDTHelper;

import java.util.Iterator;
import java.util.List;

import org.eclipse.jdt.core.dom.ASTNode;
import org.eclipse.jdt.core.dom.ArrayAccess;
import org.eclipse.jdt.core.dom.ArrayCreation;
import org.eclipse.jdt.core.dom.ArrayInitializer;
import org.eclipse.jdt.core.dom.Assignment;
import org.eclipse.jdt.core.dom.BooleanLiteral;
import org.eclipse.jdt.core.dom.BreakStatement;
import org.eclipse.jdt.core.dom.CastExpression;
import org.eclipse.jdt.core.dom.CatchClause;
import org.eclipse.jdt.core.dom.ClassInstanceCreation;
import org.eclipse.jdt.core.dom.ConditionalExpression;
import org.eclipse.jdt.core.dom.ConstructorInvocation;
import org.eclipse.jdt.core.dom.ContinueStatement;
import org.eclipse.jdt.core.dom.CreationReference;
import org.eclipse.jdt.core.dom.Dimension;
import org.eclipse.jdt.core.dom.DoStatement;
import org.eclipse.jdt.core.dom.EnhancedForStatement;
import org.eclipse.jdt.core.dom.Expression;
import org.eclipse.jdt.core.dom.ExpressionMethodReference;
import org.eclipse.jdt.core.dom.ExpressionStatement;
import org.eclipse.jdt.core.dom.FieldAccess;
import org.eclipse.jdt.core.dom.FieldDeclaration;
import org.eclipse.jdt.core.dom.ForStatement;
import org.eclipse.jdt.core.dom.IfStatement;
import org.eclipse.jdt.core.dom.InfixExpression;
import org.eclipse.jdt.core.dom.Initializer;
import org.eclipse.jdt.core.dom.InstanceofExpression;
import org.eclipse.jdt.core.dom.IntersectionType;
import org.eclipse.jdt.core.dom.LabeledStatement;
import org.eclipse.jdt.core.dom.LambdaExpression;
import org.eclipse.jdt.core.dom.MethodDeclaration;
import org.eclipse.jdt.core.dom.MethodInvocation;
import org.eclipse.jdt.core.dom.NullLiteral;
import org.eclipse.jdt.core.dom.NumberLiteral;
import org.eclipse.jdt.core.dom.ParenthesizedExpression;
import org.eclipse.jdt.core.dom.PostfixExpression;
import org.eclipse.jdt.core.dom.PrefixExpression;
import org.eclipse.jdt.core.dom.PrimitiveType;
import org.eclipse.jdt.core.dom.QualifiedName;
import org.eclipse.jdt.core.dom.QualifiedType;
import org.eclipse.jdt.core.dom.ReturnStatement;
import org.eclipse.jdt.core.dom.SimpleName;
import org.eclipse.jdt.core.dom.SimpleType;
import org.eclipse.jdt.core.dom.SingleVariableDeclaration;
import org.eclipse.jdt.core.dom.StringLiteral;
import org.eclipse.jdt.core.dom.SuperConstructorInvocation;
import org.eclipse.jdt.core.dom.SuperFieldAccess;
import org.eclipse.jdt.core.dom.SuperMethodInvocation;
import org.eclipse.jdt.core.dom.SwitchCase;
import org.eclipse.jdt.core.dom.SwitchStatement;
import org.eclipse.jdt.core.dom.SynchronizedStatement;
import org.eclipse.jdt.core.dom.ThisExpression;
import org.eclipse.jdt.core.dom.ThrowStatement;
import org.eclipse.jdt.core.dom.TryStatement;
import org.eclipse.jdt.core.dom.TypeDeclarationStatement;
import org.eclipse.jdt.core.dom.TypeLiteral;
import org.eclipse.jdt.core.dom.UnionType;
import org.eclipse.jdt.core.dom.VariableDeclarationExpression;
import org.eclipse.jdt.core.dom.VariableDeclarationFragment;
import org.eclipse.jdt.core.dom.VariableDeclarationStatement;
import org.eclipse.jdt.core.dom.WhileStatement;

import cn.yyx.research.language.JDTManager.GCodeMetaInfo;
import cn.yyx.research.language.JDTManager.KindLibrary;
import cn.yyx.research.language.JDTManager.VHiddenClassPoolManager;
import cn.yyx.research.language.JDTManager.VLabelPoolManager;
import cn.yyx.research.language.JDTManager.VVarObjPoolManager;

public class ForwardMethodPreProcessASTVisitor extends MyPreProcessASTVisitor {
	
	// TODO (later half part not solved.) method invocation not need to set parameters into the generated code but parameters need to have some prefix to indicate this is a parameter of a method.
	// TODO not only method invocation, switch while if for such all need prefix. judgment, update, no-prefix block, and others all need to be prefixed.
	// TODO = + such operations need to change to first order.
	// TODO out of scope variables are thought as First declared.
	// TODO offset still the assignment but method invoke of an object is taken as assignment.
	// TODO record only assignments in a pool. reference offset is the offset to the index of assignment in the poll at reverse order.
	// TODO first used element is also in this pool and taken as first declared or first assignment.
	// TODO In pool, scope is taken into consideration including field. offset must be as this kind: -1/-2#. first part means -1 level, second part means -2 offset in assignment.
	// TODO the offset must record which kind of sub pool it is being offset. sub pool include: final(constant), class(hidden, generated by me), var or obj, or others?.
	// TODO AddEquivalentScope(node, node.get);
	
	// TODO if nothing found in data pool, should return first declared.
	// TODO check the call of DataNewlyUsed function and the call of AddDataReferenceHint.
	
	// For one visit, there are two tasks: 
	// task 1. raw code. generated raw node code which is stored in NodeCodeManager.
	// task 2. operation & line type. generate codes which have OperationType and line type but not have line offset info.
	
	// For one visit, there are two hidden tasks:
	// 1. set node level and its child's node level indication.
	// 2. for code not put in this line, set HoleManager.
	
	// one line code could offer only one content holder.
	// type a is set, when in first order, the already handled has occupied a line.
	// type c(hole) is set, when the node has occupied a line.
	
	public ForwardMethodPreProcessASTVisitor() {
	}
	
	@Override
	public boolean visit(CreationReference node) {
		System.out.println("CreationReference:" + node);
		return super.visit(node);
	}
	
	@Override
	public boolean visit(Dimension node) {
		// []
		System.out.println("Dimension:" + node);
		return super.visit(node);
	}
	
	@Override
	public boolean visit(IntersectionType node) {
		System.out.println("IntersectionType:" + node);
		return super.visit(node);
	}
	
	@Override
	public boolean visit(UnionType node) {
		System.out.println("UnionType:" + node);
		return super.visit(node);
	}
	
	@Override
	public boolean visit(TypeLiteral node) {
		 System.out.println("TypeLiteral:" + node);
		// UnchangedNode(node);
		return super.visit(node);
	}

	@Override
	public boolean visit(TypeDeclarationStatement node) {
		// Do not know what it is now.
		 System.out.println("TypeDeclarationStatement:"+node);
		return super.visit(node);
	}
	
	@Override
	public boolean visit(LambdaExpression node) {
		// System.out.println("LambdaExpressionBegin:");
		// System.out.println("LambdaExpression:"+node);
		// System.out.println("LambdaExpressionHasParenthese:"+node.hasParentheses());
		// System.out.println("LambdaExpressionParameters:"+node.parameters());
		// System.out.println("LambdaExpressionBody:"+node.getBody());
		// System.out.println("LambdaExpressionEnd.");
		EnterBlock(node, false);
		// EnterLambdaParam(node);
		// OneTextOneLine(OperationType.LambdaExpression + "#", (node.hasParentheses() ? 1 : 0) + "#");
		/*AddFirstOrderTask(new FirstOrderTask(lastdec, node.getBody(), node, false) {
			@Override
			public void run() {
				// ExitLambdaParam(node);
				int line = VisitLineOccupy(node);
				String code = OperationType.LambdaExpression + "#";
				EndVisitReplaceLineOccupyWithRealContent(line, node, code);
			}
		});*/
		return super.visit(node);
	}
	
	@Override
	@SuppressWarnings("unchecked")
	public void endVisit(LambdaExpression node) {
		String pre = "";
		String post = "";
		if (node.hasParentheses())
		{
			pre = "(";
			post = ")";
		}
		StringBuilder cnt = new StringBuilder("");
		List<ASTNode> params = node.parameters();
		if (params!=null && params.size() > 0)
		{
			Iterator<ASTNode> itr = params.iterator();
			while (itr.hasNext())
			{
				ASTNode para = itr.next();
				String str = para.toString();
				String[] decs = str.split(" ");
				if (decs.length == 1)
				{
					cnt.append(GCodeMetaInfo.NoDeclaredType).append(",");
					DataNewlyUsed(decs[0], VVarObjPoolManager.VarOrObjPool, false, true);
				}
				else if (decs.length == 2)
				{
					cnt.append(decs[0]).append(",");
					DataNewlyUsed(decs[1], VVarObjPoolManager.VarOrObjPool, false, true);
				}
				else
				{
					System.err.println("What Lambda Param? Serious error: over two modules in a param. The program will exit.");
					System.exit(1);
				}
			}
			cnt.deleteCharAt(cnt.length()-1);
		}
		String code = pre + cnt.toString() + post + "->";
		AddNodeInMultipleLineWhenRemainIsContentHolder(node.getBody(), node);
		code = PushBackContentHolder(code, node);
		AddNodeCode(node, code);
		AddNodeHasOccupiedOneLine(node, true);
		
		ExitBlock();
	}
	
	@Override
	public boolean visit(ExpressionMethodReference node) {
		// System.out.println("ExpressionMethodReference:"+node);
		// System.out.println("ExpressionMethodReferenceExpr:"+);
		// System.out.println("ExpressionMethodReferenceName:"+node.getName());
		/*AddFirstOrderTask(new FirstOrderTask(node.getExpression(), node.getName(), node, true) {
			@Override
			public void run() {
				int line = VisitLineOccupy(node);
				String exprcode = LineOccupied(node.getExpression()) ? "" : GetRefCode(node.getExpression(), line);
				String code = OperationType.ExpressionMethodReference + "#" + this.getPost().toString() + "#" + exprcode;
				EndVisitReplaceLineOccupyWithRealContent(line, node, code);
			}
		});*/
		AddNodeCode(node, "::"+node.getName());
		AddNodeHasOccupiedOneLine(node, true);
		return super.visit(node);
	}
	
	// CLASS offset is special, relate to code offset. Solved.
	// Only 'assignment' records the line position of one variable. Solved.

	// Initializers in for is null. Solved.
	// Array initializer is null and there are many other nulls. Solved.

	@Override
	public void endVisit(ArrayInitializer node) {
		// System.out.println("ArrayInitializer:"+node);
		AddNodeCode(node, GCodeMetaInfo.ArrayInitial);
	}
	
	@Override
	public void endVisit(ArrayCreation node) {
		// System.out.println("ArrayCreation:"+node);
		AddNodeCode(node, GCodeMetaInfo.ArrayCreation);
	}
	
	@Override
	public void endVisit(CastExpression node) {
		String code = "(" + node.getType().toString() + ")";
		AddNodeInMultipleLineWhenRemainIsContentHolder(node.getExpression(), node);
		code = PushBackContentHolder(code, node);
		AddNodeCode(node, code);
		AddNodeHasOccupiedOneLine(node, true);
		
		/*int line = GetOccupiedLine(node);
		String expr = GetRefCode(node.getExpression(), line);
		Integer typeline = clm.GetClassLineInfo();
		String typestr = null;
		if (typeline == null) {
			typestr = GCodeMetaInfo.OutofScopeDesc;
		} else {
			typestr = OffsetLibrary.GetOffsetDescription(typeline - line);
		}
		String code = OperationType.CastExpression + "#" + typestr + expr;
		EndVisitReplaceLineOccupyWithRealContent(line, node, code);
		clm.AddClassLineInfo(node.getType().toString(), line);*/
	}
	
	@Override
	public boolean visit(ArrayAccess node) {
		AddReferenceUpdateHint(node.getArray(), KindLibrary.DataRefUpdate);
		return super.visit(node);
	};
	
	@Override
	public void endVisit(ArrayAccess node) {
		/*
		 * String arrstr = node.getArray().toString(); boolean isfield = false;
		 * if (arrstr.startsWith("this.")) { isfield = true; arrstr =
		 * arrstr.substring("this.".length()); } int arrline =
		 * dlm.GetDataLineInfo(arrstr, isfield); (arrline - line) + "#"
		 */
		String code = GetNodeCode(node.getArray());
		ASTNode idx = node.getIndex();
		if (GetNodeHasOccupiedOneLine(idx))
		{
			code+="[" + GCodeMetaInfo.CodeHole + "]";
		}
		else
		{
			code+="[" + GetNodeCode(idx) + "]";
		}
		AddNodeCode(node, code);
		
		DeleteReferenceUpdateHint(node);
	}
	
	@Override
	public boolean visit(Assignment node) {
		AddReferenceUpdateHint(node.getLeftHandSide(), KindLibrary.DataRefUpdate);
		return super.visit(node);
	}
	
	@Override
	public void endVisit(Assignment node) {
		/*int line = GetOccupiedLine(node);
		String left = GetRefCode(node.getLeftHandSide(), line);
		String right = GetRefCode(node.getRightHandSide(), line);
		String code = OperationType.Assignment + "#" + node.getOperator() + "#" + left + right;
		EndVisitReplaceLineOccupyWithRealContent(line, node, code);
		String data = node.getLeftHandSide().toString();
		if (node.getLeftHandSide() != null && node.getLeftHandSide() instanceof ArrayAccess) {
			data = ((ArrayAccess) node.getLeftHandSide()).getArray().toString();
		}
		dlm.AddDataLineInfo(data, line, false, false);*/
		String code = "";
		ASTNode left = node.getLeftHandSide();
		if (!GetNodeHasOccupiedOneLine(left))
		{
			code = GetNodeCode(left)+node.getOperator().toString();
			AddNodeInMultipleLineWhenRemainIsContentHolder(node.getRightHandSide(), node);
		}
		else
		{
			code = node.getOperator().toString();
			AddNodeInMultipleLine(node, true);
		}
		code = PushBackContentHolder(code, node);
		AddNodeCode(node, code);
		AddNodeHasOccupiedOneLine(node, true);
		
		DeleteReferenceUpdateHint(node);
	}

	@Override
	public void endVisit(BooleanLiteral node) {
		// System.out.println("BooleanLiteral:"+node);
		AddNodeCode(node, node.toString());
	}
	
	@Override
	public boolean visit(BreakStatement node) {
		ASTNode label = node.getLabel();
		if (label != null)
		{
			AddReferenceUpdateHint(label, KindLibrary.LabelRefUse);
		}
		return super.visit(node);
	}
	
	@Override
	public void endVisit(BreakStatement node) {
		// System.out.println("BreakStatement:"+node);
		// System.out.println(node.getLabel());
		ASTNode label = node.getLabel();
		String code = "break" + label == null ? "" : GCodeMetaInfo.WhiteSpaceReplacer+GetNodeCode(label);
		AddNodeCode(node, code);
		AddNodeHasOccupiedOneLine(node, true);
		
		DeleteReferenceUpdateHint(node);
	}
	
	@Override
	public boolean visit(ContinueStatement node) {
		ASTNode label = node.getLabel();
		if (label != null)
		{
			AddReferenceUpdateHint(label, KindLibrary.LabelRefUse);
		}
		return super.visit(node);
	}
	
	@Override
	public void endVisit(ContinueStatement node) {
		ASTNode label = node.getLabel();
		String code = "continue" + label == null ? "" : GCodeMetaInfo.WhiteSpaceReplacer+GetNodeCode(label);
		AddNodeCode(node, code);
		AddNodeHasOccupiedOneLine(node, true);
		
		DeleteReferenceUpdateHint(node);
	}
	
	@Override
	@SuppressWarnings("unchecked")
	public void endVisit(ClassInstanceCreation node) {
		// System.out.println("Node Type:"+node.getType());
		// System.out.println("Body:"+node.getAnonymousClassDeclaration());
		// System.out.println("ClassInstanceCreation:"+node);
		StringBuilder code = new StringBuilder("new" + GCodeMetaInfo.WhiteSpaceReplacer);
		MethodInvocationCode(node.getType().toString(), node.arguments(), code);
		AddNodeCode(node, code.toString());
		AddNodeHasOccupiedOneLine(node, true);
		if (node.getAnonymousClassDeclaration() != null)
		{
			AddNodeInMultipleLine(node, true);
		}
	}
	
	@Override
	public void endVisit(ConditionalExpression node) {
		ASTNode judge = node.getExpression();
		String thenexprcode = GCodeMetaInfo.CodeHole;
		ASTNode thenexpr = node.getThenExpression();
		if (!GetNodeHasOccupiedOneLine(thenexpr))
		{
			thenexprcode = GetNodeCode(thenexpr);
		}
		String elseexprcode = GCodeMetaInfo.CodeHole;
		ASTNode elseexpr = node.getElseExpression();
		if (!GetNodeHasOccupiedOneLine(elseexpr))
		{
			elseexprcode = GetNodeCode(elseexpr);
		}
		String code = "?"+thenexprcode+":"+elseexprcode;
		if (!GetNodeInMultipleLine(judge))
		{
			code = GetNodeCode(judge)+code;
		}
		AddNodeCode(node, code);
		AddNodeHasOccupiedOneLine(node, true);
		AddNodeInMultipleLine(node, true);
	}

	@Override
	@SuppressWarnings("unchecked")
	public void endVisit(ConstructorInvocation node) {
		// Do nothing now.
		// System.out.println("ConstructorInvocation:" + node);
		StringBuilder code = new StringBuilder("");
		boolean isInOneLine = MethodInvocationCode("this", node.arguments(), code);
		AddNodeCode(node, code.toString());
		AddNodeHasOccupiedOneLine(node, true);
		if (!isInOneLine)
		{
			AddNodeInMultipleLine(node, true);
		}
	}

	@Override
	public boolean visit(DoStatement node) {
		// System.out.println("Do statement begin:");
		// System.out.println("DoStatement:"+node);
		// System.out.println("Do statement end.");
		
		// Remember to add "do" in code line.
		return super.visit(node);
	}

	@Override
	public void endVisit(DoStatement node) {
		String exprcode = "";
		ASTNode expr = node.getExpression();
		if (GetNodeInMultipleLine(expr))
		{
			exprcode = GCodeMetaInfo.ContentHolder;
			AddNodeInMultipleLine(node, true);
			AddNodeHasContentHolder(node, true);
		}
		else
		{
			exprcode = GetNodeCode(expr);
		}
		String code = "while"+ GCodeMetaInfo.WhiteSpaceReplacer + exprcode;
		// this expr needs to register level.
		AddNodeCode(node, code);
		AddNodeHasOccupiedOneLine(node, true);
	}
	
	@Override
	public boolean visit(EnhancedForStatement node) {
		// System.out.println("EnhancedForStatementParameter:"+node.getParameter());
		// System.out.println("EnhancedForStatementExpr:"+node.getExpression());
		// System.out.println("EnhancedForStatementBody:"+node.getBody());
		EnterBlock(node, false);
		return super.visit(node);
	}
	
	@Override
	public void endVisit(EnhancedForStatement node) {
		String exprcode = GCodeMetaInfo.CodeHole;
		ASTNode expr = node.getExpression();
		if (!GetNodeInMultipleLine(expr))
		{
			exprcode = GetNodeCode(expr);
		}
		else
		{
			AddNodeInMultipleLine(node, true);
		}
		String code = "for(" + node.getParameter().getType().toString() + ":" + exprcode + ")";
		AddNodeCode(node, code);
		AddNodeHasOccupiedOneLine(node, true);
		
		ExitBlock();
	}

	@Override
	public boolean visit(ExpressionStatement node) {
		// This method is too high level, almost useless.
		// System.out.println("ExpressionStatement:"+node);
		AddLinkBetweenNodes(node, node.getExpression());
		return super.visit(node);
	}

	@Override
	public boolean visit(FieldAccess node) {
		// System.out.println("FieldAccess:"+node);
		// System.out.println("FieldAccessName:"+node.getName());
		// System.out.println("FieldAccessExpr:"+node.getExpression());
		ASTNode expr = node.getExpression();
		if (expr != null)
		{
			AddReferenceUpdateHint(expr, KindLibrary.DataRefUpdate);
		}
		return super.visit(node);
	}

	@Override
	public void endVisit(FieldAccess node) {
		ASTNode preexpr = node.getExpression();
		String preexprstr = preexpr.toString();
		String code = "";
		if (preexprstr.equals("this")) {
			code = GetDataOffset(node.getName().toString(), VVarObjPoolManager.VarOrObjPool);
			DataNewlyUsed(node.getName().toString(), VVarObjPoolManager.VarOrObjPool, false, false);
			// fanm.AddFieldAccessNode(node);
		} else {
			if (GetNodeInMultipleLine(preexpr))
			{
				code = "."+node.getName().toString();
				AddNodeInMultipleLine(node, true);
			}
			else
			{
				code = GetNodeCode(preexpr)+"."+node.getName().toString();
			}
		}
		AddNodeCode(node, code);
		
		DeleteReferenceUpdateHint(node);
	}

	@Override
	public boolean visit(SuperFieldAccess node) {
		// System.out.println("SuperFieldAccess:"+node);
		AddNodeCode(node, node.toString());
		return super.visit(node);
	}
	
	@Override
	@SuppressWarnings("unchecked")
	public void endVisit(SuperMethodInvocation node) {
		StringBuilder code = new StringBuilder("");
		boolean isInOneLine = MethodInvocationCode(node.getName().toString(), node.arguments(), code);
		AddNodeCode(node, "super."+code.toString());
		AddNodeHasOccupiedOneLine(node, true);
		if (!isInOneLine)
		{
			AddNodeInMultipleLine(node, true);
		}
	}
	
	@Override
	@SuppressWarnings("unchecked")
	public void endVisit(MethodInvocation node) {
		StringBuilder code = new StringBuilder("");
		boolean isInOneLine = MethodInvocationCode(node.getName().toString(), node.arguments(), code);
		AddNodeCode(node, code.toString());
		AddNodeHasOccupiedOneLine(node, true);
		if (!isInOneLine)
		{
			AddNodeInMultipleLine(node, true);
		}
	}
	
	@Override
	@SuppressWarnings("unchecked")
	public boolean visit(ForStatement node) {
		EnterBlock(node, false);
		
		List<ASTNode> inis = node.initializers();
		for (ASTNode ininode : inis)
		{
			AddReferenceUpdateHint(ininode, KindLibrary.DataRefUpdate);
		}
		List<ASTNode> ups = node.updaters();
		for (ASTNode upnode : ups)
		{
			AddReferenceUpdateHint(upnode, KindLibrary.DataRefUpdate);
		}
		return super.visit(node);
	}
	
	@Override
	@SuppressWarnings("unchecked")
	public void endVisit(ForStatement node) {
		StringBuilder code = new StringBuilder("for");
		List<ASTNode> inis = node.initializers();
		List<ASTNode> ups = node.updaters();
		/*code.append("for(");
		
		if (inis.size() > 1)
		{
			System.out.println("Appeared! Mutiple ForStatement initializers In legend.");
			System.exit(1);
		}
		if (inis.size() > 0)
		{
			ASTNode iniexpr = inis.get(0);
			code.append(GetNodeCode(iniexpr));
		}
		code.append(";");
		
		ASTNode judge = node.getExpression();
		if (judge != null)
		{
			if (!GetNodeInMultipleLine(judge))
			{
				code.append(GetNodeCode(judge));
			}
			else
			{
				code.append(GCodeMetaInfo.CodeHole);
			}
		}
		code.append(";");
		
		List<ASTNode> ups = node.updaters();
		if (ups.size() > 1)
		{
			System.out.println("Appeared! Mutiple ForStatement updaters In legend.");
			System.exit(1);
		}
		if (ups.size() > 0)
		{
			ASTNode upexpr = ups.get(0);
			code.append(GetNodeCode(upexpr));
		}
		code.append(")");*/
		
		AddNodeCode(node, code.toString());
		AddNodeHasOccupiedOneLine(node, true);
		AddNodeInMultipleLine(node, true);
		
		for (ASTNode ininode : inis)
		{
			DeleteReferenceUpdateHint(ininode);
		}
		for (ASTNode upnode : ups)
		{
			DeleteReferenceUpdateHint(upnode);
		}
		
		ExitBlock();
	}
	
	@Override
	@SuppressWarnings("unchecked")
	public boolean visit(VariableDeclarationExpression node) {
		// System.out.println("VariableDeclarationExpression:" + node);
		// for (int i=0,j=0;...) 's int i=0,j=0
		List<VariableDeclarationFragment> fs = node.fragments();
		for (VariableDeclarationFragment vdf : fs) {
			AddReferenceUpdateHint(vdf.getName(), KindLibrary.DataRefDeclare);
		}
		return super.visit(node);
	}
	
	@Override
	@SuppressWarnings("unchecked")
	public void endVisit(VariableDeclarationExpression node) {
		String type = node.getType().toString();
		List<VariableDeclarationFragment> fs = node.fragments();
		StringBuilder code = new StringBuilder("");
		if (fs != null && fs.size() > 0)
		{
			for (VariableDeclarationFragment vdf : fs) {
				code.append(type);
				Expression iniexpr = vdf.getInitializer();
				if (iniexpr != null) {
					if (!GetNodeHasOccupiedOneLine(iniexpr))
					{
						code.append("=");
						code.append(GetNodeCode(iniexpr));
					}
					DataNewlyUsed(vdf.getName().toString(), VVarObjPoolManager.VarOrObjPool, false, true);
				}
				code.append(",");
			}
			code.deleteCharAt(code.length()-1);
		}
		AddNodeCode(node, code.toString());
		
		for (VariableDeclarationFragment vdf : fs) {
			DeleteReferenceUpdateHint(vdf);
		}
	}
	
	@Override
	public boolean visit(IfStatement node) {
		// System.out.println("IfStatement:"+node);
		// System.out.println("IfStatementExpr:"+node.getExpression());
		// System.out.println("IfStatementThen:"+node.getThenStatement());
		// System.out.println("IfStatementElse:"+node.getThenStatement());
		EnterBlock(node, false);
		return super.visit(node);
	}

	@Override
	public void endVisit(IfStatement node) {
		// blockstack.pop();
		StringBuilder code = new StringBuilder("if");
		
		AddNodeCode(node, code.toString());
		AddNodeHasOccupiedOneLine(node, true);
		AddNodeInMultipleLine(node, true);
		
		/*int line = GetOccupiedLine(node);
		String thencode = node.getThenStatement() == null ? GCodeMetaInfo.NoStatement
				: GetRefCode(node.getThenStatement(), line);
		String elsecode = node.getElseStatement() == null ? GCodeMetaInfo.NoStatement
				: GetRefCode(node.getElseStatement(), line);
		String code = OperationType.IfStatement + "#" + GetRefCode(node.getExpression(), line) + thencode + elsecode;*/
		
		ExitBlock();
	}
	
	@Override
	@SuppressWarnings("unchecked")
	public void endVisit(InfixExpression node) {
		boolean inMultipleLine = false;
		String leftcode = "";
		ASTNode left = node.getLeftOperand();
		if (!GetNodeHasOccupiedOneLine(left))
		{
			leftcode = GetNodeCode(left);
		}
		else
		{
			leftcode = GCodeMetaInfo.CodeHole;
			inMultipleLine = true;
		}
		String rightcode = "";
		ASTNode right = node.getRightOperand();
		if (!GetNodeHasOccupiedOneLine(right))
		{
			rightcode = GetNodeCode(left);
		}
		else
		{
			rightcode = GCodeMetaInfo.CodeHole;
			inMultipleLine = true;
		}
		String code = leftcode + node.getOperator().toString() + rightcode;
		List<Expression> ops = node.extendedOperands();
		if (!inMultipleLine && ops.size() > 0)
		{
			inMultipleLine = true;
		}
		
		AddNodeCode(node, code);
		AddNodeHasOccupiedOneLine(node, true);
		if (inMultipleLine)
		{
			AddNodeInMultipleLine(node, true);
		}
		
		/*int opline = line;
		for (Expression op : ops) {
			opline++;
			String opcode = OperationType.InfixExpression + "#" + node.getOperator().toString() + "#"
					+ OffsetLibrary.GetOffsetDescription(line - opline) + GetRefCode(op, opline);
			lcm.AddLineCode(opline, opcode);
			// code += GetRefCode(op, line);
		}*/
		/*
		 * System.out.println("=========传说中的分割线==开始==========");
		 * System.out.println("InfixExpression:"+node);
		 * System.out.println(node.getOperator());
		 * System.out.println(node.getLeftOperand());
		 * System.out.println(node.getRightOperand());
		 * System.out.println("=========传说中的分割线==中间==========");
		 * List<Expression> opso = node.extendedOperands(); for (Expression op :
		 * opso) { System.out.println(op); }
		 * System.out.println("=========传说中的分割线==结束==========");
		 */
	}
	
	@Override
	public boolean visit(Initializer node) {
		// Do nothing now.
		// System.out.println("Initializer:"+node);
		ResetDLM();
		return super.visit(node);
	}
	
	@Override
	public boolean visit(InstanceofExpression node) {
		// System.out.println("InstanceofExpression:"+node);
		// System.out.println("InstanceofExpressionLeft:"+node.getLeftOperand());
		// System.out.println("InstanceofExpressionRight:"+node.getRightOperand());
		return super.visit(node);
	}
	
	@Override
	public void endVisit(InstanceofExpression node) {
		String type = node.getRightOperand().toString();
		String typecode = GetDataOffset(type, VHiddenClassPoolManager.ClassHiddenPool);
		DataNewlyUsed(type, VHiddenClassPoolManager.ClassHiddenPool, false, false);
		ASTNode left = node.getLeftOperand();
		String leftcode = GCodeMetaInfo.CodeHole;
		if (!GetNodeInMultipleLine(left))
		{
			leftcode = GetNodeCode(left);
		}
		else
		{
			AddNodeInMultipleLine(node, true);
		}
		String code = leftcode + GCodeMetaInfo.WhiteSpaceReplacer + "instanceof" + GCodeMetaInfo.WhiteSpaceReplacer + typecode;
		
		AddNodeCode(node, code);
		AddNodeHasOccupiedOneLine(node, true);
	}
	
	@Override
	public boolean visit(LabeledStatement node) {
		// System.out.println("LabeledStatement:"+node);
		AddNodeCode(node, node.getLabel().toString());
		AddNodeHasOccupiedOneLine(node, true);
		
		DataNewlyUsed(node.getLabel().toString(), VLabelPoolManager.LabelPool, false, false);
		return super.visit(node);
	}
	
	@Override
	public void endVisit(ParenthesizedExpression node) {
		// System.out.println("ParenthesizedExpression:"+node);
		// System.out.println("ParenthesizedExpression:"+node.getExpression());
		AddLinkBetweenNodes(node, node.getExpression());
	}
	
	@Override
	public boolean visit(NullLiteral node) {
		// System.out.println("NullLiteral:"+node);
		AddNodeCode(node, node.toString());
		return super.visit(node);
	}
	
	@Override
	public void endVisit(PostfixExpression node) {
		// System.out.println("PostfixExpression:"+node);
		// System.out.println("PostfixExpressionOperator:"+node.getOperator());
		// System.out.println("PostfixExpressionOperand:"+node.getOperand());
		String exprcode = "";
		ASTNode expr = node.getOperand();
		
		AddReferenceUpdateHint(expr, KindLibrary.DataRefUpdate);
		
		if (GetNodeInMultipleLine(expr))
		{
			exprcode = GCodeMetaInfo.CodeHole;
			AddNodeInMultipleLine(node, true);
		}
		else
		{
			exprcode = GetNodeCode(expr);
		}
		String code = exprcode + node.getOperator();
		AddNodeCode(node, code);
		AddNodeHasOccupiedOneLine(node, true);
	}
	
	@Override
	public void endVisit(PrefixExpression node) {
		// System.out.println("PrefixExpression:"+node);
		// System.out.println("PrefixExpressionOperator:"+node.getOperator());
		// System.out.println("PrefixExpressionOperand:"+node.getOperand());
		String exprcode = "";
		ASTNode expr = node.getOperand();
		
		AddReferenceUpdateHint(expr, KindLibrary.DataRefUpdate);
		
		if (GetNodeInMultipleLine(expr))
		{
			exprcode = GCodeMetaInfo.ContentHolder;
			AddNodeInMultipleLine(node, true);
			AddNodeHasContentHolder(node, true);
		}
		else
		{
			exprcode = GetNodeCode(expr);
		}
		String code = node.getOperator() + exprcode;
		AddNodeCode(node, code);
		AddNodeHasOccupiedOneLine(node, true);
	}

	@Override
	public boolean visit(QualifiedName node) {
		// System.out.println("QualifiedName:"+node);
		AddNodeCode(node, node.toString());
		return super.visit(node);
	}
	
	@Override
	public void endVisit(ReturnStatement node) {
		ASTNode expr = node.getExpression();
		String exprcode = GetNodeCode(expr);
		if (GetNodeInMultipleLine(expr))
		{
			exprcode = GCodeMetaInfo.ContentHolder;
			AddNodeHasContentHolder(node, true);
			AddNodeInMultipleLine(node, true);
		}
		String code = "return" + GCodeMetaInfo.WhiteSpaceReplacer + exprcode;
		AddNodeCode(node, code);
		AddNodeHasOccupiedOneLine(node, true);
	}
	
	@Override
	public boolean visit(PrimitiveType node) {
		// System.out.println("PrimitiveType:" + node);
		AddNodeCode(node, node.toString());
		return super.visit(node);
	}
	
	@Override
	public boolean visit(SimpleType node) {
		// System.out.println("SimpleType:" + node);
		AddNodeCode(node, node.toString());
		DataNewlyUsed(node.toString(), VHiddenClassPoolManager.ClassHiddenPool, false, false);
		return super.visit(node);
	}
	
	@Override
	public boolean visit(QualifiedType node) {
		// System.out.println("QualifiedType:"+node);
		AddNodeCode(node, node.toString());
		DataNewlyUsed(node.toString(), VHiddenClassPoolManager.ClassHiddenPool, false, false);
		return super.visit(node);
	}
	
	@Override
	public boolean visit(StringLiteral node) {
		// System.out.println("StringLiteral:"+node);
		AddNodeCode(node, GCodeMetaInfo.StringHolder);
		return super.visit(node);
	}
	
	@Override
	public boolean visit(NumberLiteral node) {
		// System.out.println("NumberLiteral:"+node);
		AddNodeCode(node, GCodeMetaInfo.NumberHolder);
		return super.visit(node);
	}
	
	@Override
	@SuppressWarnings("unchecked")
	public void endVisit(SuperConstructorInvocation node) {
		StringBuilder code = new StringBuilder("");
		boolean isInOneLine = MethodInvocationCode("super", node.arguments(), code);
		AddNodeCode(node, code.toString());
		AddNodeHasOccupiedOneLine(node, true);
		if (!isInOneLine)
		{
			AddNodeInMultipleLine(node, true);
		}
	}
	
	@Override
	public boolean visit(SwitchStatement node) {
		// System.out.println("SwitchStatement:"+node);
		// System.out.println("SwitchStatementExpr:"+node.getExpression());
		// blockstack.push(node.hashCode());
		EnterBlock(node, false);
		return super.visit(node);
	}
	
	@Override
	public void endVisit(SwitchStatement node) {
		ASTNode expr = node.getExpression();
		String exprcode = GetNodeCode(expr);
		if (GetNodeInMultipleLine(expr))
		{
			exprcode = GCodeMetaInfo.ContentHolder;
			AddNodeHasContentHolder(node, true);
		}
		String code = "switch" + GCodeMetaInfo.WhiteSpaceReplacer + GCodeMetaInfo.WhiteSpaceReplacer + exprcode;
		AddNodeCode(node, code);
		AddNodeHasOccupiedOneLine(node, true);
		AddNodeInMultipleLine(node, true);
		
		ExitBlock();
	}
	
	@Override
	public void endVisit(SwitchCase node) {
		ASTNode expr = node.getExpression();
		String code = "default";
		if (expr != null)
		{
			code = "case" + GCodeMetaInfo.WhiteSpaceReplacer;
			if (GetNodeInMultipleLine(expr))
			{
				code += GCodeMetaInfo.ContentHolder;
				AddNodeHasContentHolder(node, true);
			}
			else
			{
				code += GetNodeCode(expr);
			}
		}
		AddNodeCode(node, code);
		AddNodeHasOccupiedOneLine(node, true);
		AddNodeInMultipleLine(node, true);
	}
	
	@Override
	public void endVisit(SynchronizedStatement node) {
		String exprcode = "";
		ASTNode expr = node.getExpression();
		if (GetNodeInMultipleLine(expr))
		{
			exprcode = GCodeMetaInfo.CodeHole;
		}
		else
		{
			exprcode = GetNodeCode(expr);
		}
		String code = "synchronized(" + exprcode + ")";
		
		AddNodeCode(node, code);
		AddNodeHasOccupiedOneLine(node, true);
		AddNodeInMultipleLine(node, true);
	}
	
	@Override
	public boolean visit(ThisExpression node) {
		// System.out.println("ThisExpression:"+node);
		AddNodeCode(node, node.toString());
		return super.visit(node);
	}
	
	@Override
	public boolean visit(TryStatement node) {
		// System.out.println("TryStatement:"+node);
		// System.out.println("TryStatementBody:"+node.getBody());
		AddLinkBetweenNodes(node, node.getBody());
		return super.visit(node);
	}
	
	@Override
	public void endVisit(ThrowStatement node) {
		// System.out.println("ThrowStatement:"+node);
		ASTNode expr = node.getExpression();
		String exprcode = GetNodeCode(expr);
		if (GetNodeInMultipleLine(expr))
		{
			exprcode = GCodeMetaInfo.ContentHolder;
			AddNodeHasContentHolder(node, true);
			AddNodeInMultipleLine(node, true);
		}
		String code = "throw" + GCodeMetaInfo.WhiteSpaceReplacer + exprcode;
		AddNodeCode(node, code);
		AddNodeHasOccupiedOneLine(node, true);
	}
	
	@Override
	public void endVisit(CatchClause node) {
		// System.out.println("CatchClause:"+node);
		ASTNode expr = node.getException();
		String exprcode = GetNodeCode(expr);
		if (GetNodeInMultipleLine(expr))
		{
			exprcode = GCodeMetaInfo.ContentHolder;
			AddNodeHasContentHolder(node, true);
			AddNodeInMultipleLine(node, true);
		}
		String code = "catch" + GCodeMetaInfo.WhiteSpaceReplacer + exprcode;
		AddNodeCode(node, code);
		AddNodeHasOccupiedOneLine(node, true);
	}
	
	@Override
	public boolean visit(SingleVariableDeclaration node) {
		// System.out.println("SingleVariableDeclaration:"+node);
		// System.out.println("SingleVariableDeclarationType:"+node.getType());
		AddReferenceUpdateHint(node, KindLibrary.DataRefDeclare);
		return super.visit(node);
	}
	
	@Override
	public void endVisit(SingleVariableDeclaration node) {
		String code = node.getType().toString();
		AddNodeCode(node, code);
	}
	
	@Override
	@SuppressWarnings("unchecked")
	public boolean visit(FieldDeclaration node) {
		// System.out.println("FieldDeclaration:"+node);
		// System.out.println("FieldDeclarationParentHashcode:"+node.getParent().hashCode());
		/*List<VariableDeclarationFragment> fs = node.fragments();
		for (VariableDeclarationFragment f : fs) {
			// System.out.println("FieldDeclarationFragmentName:"+f.getName());
			dlm.AddDataLineInfo(f.getName().toString(), GCodeMetaInfo.IsField, true, false);
		}*/
		List<VariableDeclarationFragment> fs = node.fragments();
		for (VariableDeclarationFragment vdf : fs) {
			AddReferenceUpdateHint(vdf.getName(), KindLibrary.DataRefDeclare);
		}
		return super.visit(node);
	}
	
	@Override
	@SuppressWarnings("unchecked")
	public void endVisit(FieldDeclaration node) {
		String type = node.getType().toString();
		List<VariableDeclarationFragment> fs = node.fragments();
		StringBuilder code = new StringBuilder("");
		if (fs != null && fs.size() > 0)
		{
			for (VariableDeclarationFragment vdf : fs) {
				code.append(type);
				Expression iniexpr = vdf.getInitializer();
				if (iniexpr != null) {
					if (!GetNodeHasOccupiedOneLine(iniexpr))
					{
						code.append("=");
						code.append(GetNodeCode(iniexpr));
					}
					DataNewlyUsed(vdf.getName().toString(), VVarObjPoolManager.VarOrObjPool, true, false);
				}
				code.append(",");
			}
			code.deleteCharAt(code.length()-1);
		}
		AddNodeCode(node, code.toString());
		
		for (VariableDeclarationFragment vdf : fs) {
			DeleteReferenceUpdateHint(vdf);
		}
	}
	
	@Override
	public boolean visit(MethodDeclaration node) {
		// System.out.println("MethodDeclarationParent:"+node.getParent().hashCode());
		ResetDLM();
		EnterBlock(node, false);
		return super.visit(node);
	}
	
	@Override
	@SuppressWarnings("unchecked")
	public void endVisit(MethodDeclaration node) {
		List<ASTNode> types = node.typeParameters();
		Iterator<ASTNode> itr = types.iterator();
		String code = node.getName().toString();
		StringBuilder typedec = new StringBuilder("");
		while (itr.hasNext())
		{
			String type = itr.next().toString();
			typedec.append(type);
			typedec.append(",");
		}
		if (types.size() > 0)
		{
			typedec.deleteCharAt(typedec.length()-1);
		}
		code = "(" + typedec.toString() + ")";
		AddNodeCode(node, code);
		AddNodeHasOccupiedOneLine(node, true);
		AddNodeInMultipleLine(node, true);
		
		ExitBlock();
	}
	
	@Override
	@SuppressWarnings("unchecked")
	public boolean visit(VariableDeclarationStatement node) {
		// System.out.println("VariableDeclarationStatement:"+node);
		// System.out.println("VariableDeclarationStatementType:"+node.getType());
		List<VariableDeclarationFragment> fs = node.fragments();
		for (VariableDeclarationFragment vdf : fs) {
			AddReferenceUpdateHint(vdf.getName(), KindLibrary.DataRefDeclare);
		}
		return super.visit(node);
	}
	
	@Override
	@SuppressWarnings("unchecked")
	public void endVisit(VariableDeclarationStatement node) {
		String type = node.getType().toString();
		List<VariableDeclarationFragment> fs = node.fragments();
		StringBuilder code = new StringBuilder("");
		if (fs != null && fs.size() > 0)
		{
			for (VariableDeclarationFragment vdf : fs) {
				code.append(type);
				Expression iniexpr = vdf.getInitializer();
				if (iniexpr != null) {
					if (!GetNodeHasOccupiedOneLine(iniexpr))
					{
						code.append("=");
						code.append(GetNodeCode(iniexpr));
					}
					DataNewlyUsed(vdf.getName().toString(), VVarObjPoolManager.VarOrObjPool, false, true);
				}
				code.append(",");
			}
			code.deleteCharAt(code.length()-1);
		}
		AddNodeCode(node, code.toString());
		
		for (VariableDeclarationFragment vdf : fs) {
			DeleteReferenceUpdateHint(vdf);
		}
	}
	
	@Override
	public void endVisit(SimpleName node) {
		// System.out.println("SimpleName:" + node);
		Integer hint = GetReferenceUpdateHint(node);
		if (hint != null)
		{
			String code = null;
			switch (hint) {
			case KindLibrary.DataRefDeclare:
				return;
			case KindLibrary.DataRefUpdate:
				code = GetDataOffset(node.toString(), VVarObjPoolManager.VarOrObjPool);
				break;
			case KindLibrary.LabelRefUse:
				code = GetDataOffset(node.toString(), VLabelPoolManager.LabelPool);
				break;
			default:
				break;
			}
			if (code != null)
			{
				AddNodeCode(node, code);
			}
			else
			{
				System.err.println("DataOffset went wrong! No corresponding data offset.");
			}
		}
		else
		{
			AddNodeCode(node, node.toString());
			System.err.println("Warning: just for debugging and testing. The simple name does not have hint:" + node);
		}
	}
	
	@Override
	public boolean visit(WhileStatement node) {
		// System.out.println("WhileStatement:"+node);
		// System.out.println("WhileStatementExpr:"+node.getExpression());
		// System.out.println("WhileStatementBody:"+node.getBody());
		
		// this should register nlm.
		EnterBlock(node, false);
		return super.visit(node);
	}
	
	@Override
	public void endVisit(WhileStatement node) {
		ASTNode expr = node.getExpression();
		String exprcode = GetNodeCode(expr);
		if (GetNodeInMultipleLine(expr))
		{
			exprcode = GCodeMetaInfo.ContentHolder;
		}
		String code = "while" + GCodeMetaInfo.WhiteSpaceReplacer + exprcode;
		AddNodeCode(node, code);
		AddNodeHasOccupiedOneLine(node, true);
		AddNodeInMultipleLine(node, true);
		
		ExitBlock();
	}
	
}